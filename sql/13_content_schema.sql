-- =============================================
-- CONTENT SCHEMA
-- =============================================
-- Purpose: Content analysis, snapshots, topics, and semantic search
-- Dependencies: 00_extensions.sql (pgvector)
-- Phase: Tier 1, Item #3 (pgvector) + Tier 2, Item #5 (Topics)

-- Create dedicated schema for content intelligence
CREATE SCHEMA IF NOT EXISTS content;
SET search_path TO content, gsc, public;

-- =============================================
-- PAGE SNAPSHOTS TABLE
-- =============================================
-- Stores content snapshots for change detection and analysis
-- Includes embeddings for semantic similarity search

CREATE TABLE IF NOT EXISTS content.page_snapshots (
    -- Identity
    id BIGSERIAL PRIMARY KEY,
    snapshot_id UUID DEFAULT uuid_generate_v4() UNIQUE,

    -- Page identification
    property VARCHAR(500) NOT NULL,
    page_path TEXT NOT NULL,
    snapshot_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Content
    url TEXT NOT NULL,
    html_content TEXT,
    -- Raw HTML content

    text_content TEXT,
    -- Extracted plain text (cleaned)

    -- Metadata
    title TEXT,
    meta_description TEXT,
    meta_keywords TEXT,
    canonical_url TEXT,
    h1_tags TEXT[],
    h2_tags TEXT[],
    h3_tags TEXT[],
    image_count INT DEFAULT 0,
    link_count INT DEFAULT 0,
    internal_link_count INT DEFAULT 0,
    external_link_count INT DEFAULT 0,

    -- Content metrics
    word_count INT,
    character_count INT,
    paragraph_count INT,
    sentence_count INT,

    -- Readability scores
    flesch_reading_ease DECIMAL(5,2),
    -- 90-100: Very Easy, 60-70: Standard, 0-30: Very Difficult

    flesch_kincaid_grade DECIMAL(4,2),
    -- US grade level required to understand

    -- Content hash (for change detection)
    content_hash VARCHAR(64),
    -- SHA256 hash of normalized text_content

    -- Semantic embeddings (768-dimensional by default)
    content_embedding vector(768),
    -- Generated by sentence-transformers or Ollama
    -- Used for: similarity search, clustering, cannibalization detection

    title_embedding vector(768),
    -- Separate embedding for title (sometimes more relevant)

    -- Analysis metadata
    embedding_model VARCHAR(100),
    -- e.g., 'all-MiniLM-L6-v2', 'nomic-embed-text', 'llama3.1:8b'

    analyzed_at TIMESTAMP,
    analysis_version VARCHAR(20),

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    UNIQUE(property, page_path, snapshot_date),
    CHECK (word_count >= 0),
    CHECK (flesch_reading_ease IS NULL OR flesch_reading_ease BETWEEN 0 AND 100)
);

-- =============================================
-- TOPICS TABLE
-- =============================================
-- Defines content topics/clusters for organization and strategy

CREATE TABLE IF NOT EXISTS content.topics (
    -- Identity
    id SERIAL PRIMARY KEY,
    topic_id UUID DEFAULT uuid_generate_v4() UNIQUE,

    -- Topic details
    name VARCHAR(200) NOT NULL UNIQUE,
    slug VARCHAR(200) NOT NULL UNIQUE,
    description TEXT,

    -- Hierarchy
    parent_topic_id INT REFERENCES content.topics(id) ON DELETE SET NULL,
    -- Allows hierarchical topics: e.g., "SEO" → "Technical SEO"

    level INT NOT NULL DEFAULT 0,
    -- 0 = top-level, 1+ = nested

    -- Topic embedding (centroid of all pages in this topic)
    topic_embedding vector(768),

    -- Metadata
    page_count INT DEFAULT 0,
    -- Cached count of pages in this topic

    avg_performance DECIMAL(6,2),
    -- Average performance score of pages in this topic

    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CHECK (level >= 0)
);

-- =============================================
-- PAGE-TOPIC MAPPING TABLE
-- =============================================
-- Many-to-many relationship: pages can belong to multiple topics

CREATE TABLE IF NOT EXISTS content.page_topics (
    -- Composite primary key
    page_path TEXT NOT NULL,
    property VARCHAR(500) NOT NULL,
    topic_id INT REFERENCES content.topics(id) ON DELETE CASCADE,

    -- Relevance
    relevance_score FLOAT NOT NULL DEFAULT 1.0,
    -- 0.0 to 1.0: how strongly this page belongs to this topic
    -- Calculated from embedding similarity or manual assignment

    assignment_method VARCHAR(50) NOT NULL DEFAULT 'auto',
    -- auto (clustering), manual, suggested, verified

    -- Timestamps
    assigned_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    assigned_by VARCHAR(100) DEFAULT 'system',

    PRIMARY KEY (page_path, property, topic_id),
    CHECK (relevance_score BETWEEN 0 AND 1)
);

-- =============================================
-- CONTENT QUALITY SCORES TABLE
-- =============================================
-- Stores AI-generated content quality assessments

CREATE TABLE IF NOT EXISTS content.quality_scores (
    id BIGSERIAL PRIMARY KEY,
    property VARCHAR(500) NOT NULL,
    page_path TEXT NOT NULL,
    snapshot_id UUID REFERENCES content.page_snapshots(snapshot_id) ON DELETE CASCADE,

    -- Overall quality
    overall_score DECIMAL(4,2),
    -- 0-100 quality score

    -- Dimension scores
    readability_score DECIMAL(4,2),
    relevance_score DECIMAL(4,2),
    depth_score DECIMAL(4,2),
    -- Content depth/comprehensiveness

    uniqueness_score DECIMAL(4,2),
    -- How unique vs duplicate content

    optimization_score DECIMAL(4,2),
    -- SEO optimization level

    -- AI analysis
    content_summary TEXT,
    -- LLM-generated summary

    key_topics TEXT[],
    -- Extracted topics/themes

    sentiment VARCHAR(20),
    -- positive, neutral, negative

    target_audience VARCHAR(100),
    -- Detected target audience

    -- Suggestions
    improvement_suggestions TEXT[],
    missing_elements TEXT[],

    -- Analysis metadata
    analyzed_by VARCHAR(100) DEFAULT 'ollama',
    -- ollama, openai, manual

    model_version VARCHAR(100),
    confidence DECIMAL(3,2),

    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(property, page_path, created_at)
);

-- =============================================
-- CANNIBALIZATION PAIRS TABLE
-- =============================================
-- Detects content cannibalization (pages competing for same keywords)

CREATE TABLE IF NOT EXISTS content.cannibalization_pairs (
    id SERIAL PRIMARY KEY,
    property VARCHAR(500) NOT NULL,

    -- The conflicting pages
    page_a TEXT NOT NULL,
    page_b TEXT NOT NULL,

    -- Conflict metrics
    similarity_score FLOAT NOT NULL,
    -- 0.0 to 1.0: how similar the content is (from embeddings)

    shared_queries TEXT[],
    -- Queries that both pages rank for

    conflict_severity VARCHAR(20) NOT NULL DEFAULT 'medium',
    -- low, medium, high, critical

    -- Impact analysis
    estimated_traffic_loss INT,
    -- Estimated clicks lost due to cannibalization

    -- Resolution
    status VARCHAR(50) DEFAULT 'active',
    -- active, investigating, resolved, ignored

    resolution_action VARCHAR(100),
    -- merge_pages, differentiate_content, redirect, etc.

    resolved_at TIMESTAMP,
    resolved_by VARCHAR(100),
    resolution_notes TEXT,

    -- Metadata
    detected_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_checked TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CHECK (page_a < page_b),
    -- Ensures we don't store duplicate pairs (A,B) and (B,A)

    CHECK (similarity_score BETWEEN 0 AND 1),
    CHECK (conflict_severity IN ('low', 'medium', 'high', 'critical')),
    UNIQUE(property, page_a, page_b)
);

-- =============================================
-- CONTENT CHANGES TABLE
-- =============================================
-- Tracks significant content changes and their impact

CREATE TABLE IF NOT EXISTS content.content_changes (
    id BIGSERIAL PRIMARY KEY,
    property VARCHAR(500) NOT NULL,
    page_path TEXT NOT NULL,

    -- Change details
    change_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    change_type VARCHAR(50) NOT NULL,
    -- created, updated, deleted, major_update, minor_update

    -- Snapshots
    before_snapshot_id UUID REFERENCES content.page_snapshots(snapshot_id),
    after_snapshot_id UUID REFERENCES content.page_snapshots(snapshot_id),

    -- Change metrics
    word_count_delta INT,
    content_similarity FLOAT,
    -- 0.0 to 1.0: similarity between before/after

    -- What changed
    changes_summary TEXT,
    -- Human-readable summary of changes

    changed_sections TEXT[],
    -- List of sections that changed (title, meta, h1, body, etc.)

    -- Impact tracking
    traffic_before JSONB,
    -- GSC metrics before change: {clicks: 100, impressions: 5000}

    traffic_after JSONB,
    -- GSC metrics after change

    impact_measured_at TIMESTAMP,
    traffic_impact_pct DECIMAL(6,2),
    -- % change in traffic (positive = improvement)

    -- Metadata
    changed_by VARCHAR(100),
    change_reason TEXT,

    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- =============================================
-- INDEXES
-- =============================================

-- Page snapshots
CREATE INDEX IF NOT EXISTS idx_snapshots_property_page ON content.page_snapshots(property, page_path);
CREATE INDEX IF NOT EXISTS idx_snapshots_date ON content.page_snapshots(snapshot_date DESC);
CREATE INDEX IF NOT EXISTS idx_snapshots_hash ON content.page_snapshots(content_hash);

-- Vector similarity search (HNSW index for fast nearest neighbor)
CREATE INDEX IF NOT EXISTS idx_snapshots_embedding ON content.page_snapshots
    USING hnsw (content_embedding vector_cosine_ops);

CREATE INDEX IF NOT EXISTS idx_snapshots_title_embedding ON content.page_snapshots
    USING hnsw (title_embedding vector_cosine_ops)
    WHERE title_embedding IS NOT NULL;

-- Topics
CREATE INDEX IF NOT EXISTS idx_topics_slug ON content.topics(slug);
CREATE INDEX IF NOT EXISTS idx_topics_parent ON content.topics(parent_topic_id);
CREATE INDEX IF NOT EXISTS idx_topics_active ON content.topics(is_active) WHERE is_active = true;

-- Page-topic mapping
CREATE INDEX IF NOT EXISTS idx_page_topics_topic ON content.page_topics(topic_id);
CREATE INDEX IF NOT EXISTS idx_page_topics_relevance ON content.page_topics(relevance_score DESC);

-- Quality scores
CREATE INDEX IF NOT EXISTS idx_quality_property_page ON content.quality_scores(property, page_path);
CREATE INDEX IF NOT EXISTS idx_quality_overall ON content.quality_scores(overall_score DESC);

-- Cannibalization
CREATE INDEX IF NOT EXISTS idx_cannibalization_property ON content.cannibalization_pairs(property);
CREATE INDEX IF NOT EXISTS idx_cannibalization_status ON content.cannibalization_pairs(status);
CREATE INDEX IF NOT EXISTS idx_cannibalization_severity ON content.cannibalization_pairs(conflict_severity);
CREATE INDEX IF NOT EXISTS idx_cannibalization_similarity ON content.cannibalization_pairs(similarity_score DESC);

-- Content changes
CREATE INDEX IF NOT EXISTS idx_changes_property_page ON content.content_changes(property, page_path);
CREATE INDEX IF NOT EXISTS idx_changes_date ON content.content_changes(change_date DESC);
CREATE INDEX IF NOT EXISTS idx_changes_type ON content.content_changes(change_type);

-- =============================================
-- TRIGGER: Update topic page count
-- =============================================
CREATE OR REPLACE FUNCTION content.update_topic_page_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE content.topics
        SET page_count = page_count + 1
        WHERE id = NEW.topic_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE content.topics
        SET page_count = page_count - 1
        WHERE id = OLD.topic_id;
    ELSIF TG_OP = 'UPDATE' AND NEW.topic_id != OLD.topic_id THEN
        UPDATE content.topics
        SET page_count = page_count - 1
        WHERE id = OLD.topic_id;

        UPDATE content.topics
        SET page_count = page_count + 1
        WHERE id = NEW.topic_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER page_topics_update_count
    AFTER INSERT OR UPDATE OR DELETE ON content.page_topics
    FOR EACH ROW
    EXECUTE FUNCTION content.update_topic_page_count();

-- =============================================
-- VIEWS
-- =============================================

-- Latest snapshot per page
CREATE OR REPLACE VIEW content.vw_latest_snapshots AS
SELECT DISTINCT ON (property, page_path)
    *
FROM content.page_snapshots
ORDER BY property, page_path, snapshot_date DESC;

COMMENT ON VIEW content.vw_latest_snapshots IS 'Most recent snapshot for each page';

-- Content with quality scores
CREATE OR REPLACE VIEW content.vw_content_quality AS
SELECT
    s.property,
    s.page_path,
    s.title,
    s.word_count,
    s.flesch_reading_ease,
    q.overall_score,
    q.readability_score,
    q.optimization_score,
    q.content_summary,
    q.improvement_suggestions,
    s.snapshot_date,
    q.created_at AS quality_analyzed_at
FROM content.vw_latest_snapshots s
LEFT JOIN content.quality_scores q
    ON s.property = q.property
    AND s.page_path = q.page_path
    AND s.snapshot_id = q.snapshot_id
ORDER BY q.overall_score DESC NULLS LAST;

-- Active cannibalization issues
CREATE OR REPLACE VIEW content.vw_active_cannibalization AS
SELECT
    c.*,
    ARRAY_LENGTH(c.shared_queries, 1) AS shared_query_count
FROM content.cannibalization_pairs c
WHERE c.status = 'active'
ORDER BY c.conflict_severity DESC, c.similarity_score DESC;

-- =============================================
-- HELPER FUNCTIONS
-- =============================================

-- Find similar pages (semantic search)
CREATE OR REPLACE FUNCTION content.find_similar_pages(
    p_page_path TEXT,
    p_property VARCHAR,
    p_limit INT DEFAULT 10,
    p_threshold FLOAT DEFAULT 0.7
) RETURNS TABLE (
    similar_page_path TEXT,
    similarity_score FLOAT,
    title TEXT,
    word_count INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s2.page_path,
        1 - (s1.content_embedding <=> s2.content_embedding) AS similarity,
        s2.title,
        s2.word_count
    FROM content.vw_latest_snapshots s1
    CROSS JOIN content.vw_latest_snapshots s2
    WHERE s1.page_path = p_page_path
        AND s1.property = p_property
        AND s2.page_path != p_page_path
        AND s2.property = p_property
        AND s1.content_embedding IS NOT NULL
        AND s2.content_embedding IS NOT NULL
        AND (1 - (s1.content_embedding <=> s2.content_embedding)) >= p_threshold
    ORDER BY similarity DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION content.find_similar_pages IS 'Find semantically similar pages using vector embeddings';

-- =============================================
-- COMMENTS
-- =============================================
COMMENT ON SCHEMA content IS 'Content intelligence: snapshots, topics, quality, and semantic search';
COMMENT ON TABLE content.page_snapshots IS 'Historical snapshots of page content with embeddings for semantic search';
COMMENT ON TABLE content.topics IS 'Content topics/clusters for organization and strategy';
COMMENT ON TABLE content.page_topics IS 'Many-to-many mapping of pages to topics';
COMMENT ON TABLE content.quality_scores IS 'AI-generated content quality assessments';
COMMENT ON TABLE content.cannibalization_pairs IS 'Detected content cannibalization issues';
COMMENT ON TABLE content.content_changes IS 'Tracked content changes and their traffic impact';

-- =============================================
-- VERIFICATION
-- =============================================
DO $$
BEGIN
    RAISE NOTICE 'Content schema created successfully ✓';
    RAISE NOTICE 'Schema: content';
    RAISE NOTICE 'Tables: page_snapshots, topics, page_topics, quality_scores, cannibalization_pairs, content_changes';
    RAISE NOTICE 'Views: vw_latest_snapshots, vw_content_quality, vw_active_cannibalization';
    RAISE NOTICE 'Functions: find_similar_pages()';
    RAISE NOTICE 'Vector embeddings enabled with pgvector ✓';
END $$;

"""
Email Notifier
==============
Send email notifications via SMTP or SendGrid.

Features:
- SMTP support (Gmail, Office365, custom)
- SendGrid API support (optional)
- HTML email templates
- Severity-based styling
- Inline CSS for email clients
"""
import asyncio
import logging
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from typing import Dict, List, Optional

import httpx

logger = logging.getLogger(__name__)


class EmailNotifier:
    """
    Send notifications via email
    """

    SEVERITY_COLORS = {
        'low': '#36a64f',      # Green
        'medium': '#ff9900',   # Orange
        'high': '#ff0000',     # Red
        'critical': '#8b0000'  # Dark Red
    }

    def __init__(
        self,
        method: str = 'smtp',
        smtp_config: Dict = None,
        sendgrid_api_key: str = None
    ):
        """
        Initialize Email notifier

        Args:
            method: 'smtp' or 'sendgrid'
            smtp_config: SMTP configuration (host, port, username, password)
            sendgrid_api_key: SendGrid API key (if using SendGrid)
        """
        self.method = method
        self.smtp_config = smtp_config or {}
        self.sendgrid_api_key = sendgrid_api_key

        logger.info(f"EmailNotifier initialized with method: {method}")

    async def send(
        self,
        payload: Dict,
        channel_config: Dict
    ) -> bool:
        """
        Send email notification

        Args:
            payload: Alert payload
            channel_config: Email configuration

        Returns:
            True if sent successfully
        """
        try:
            # Extract configuration
            from_email = channel_config.get('from_email', self.smtp_config.get('from_email'))
            to_emails = channel_config.get('to_emails', [])

            if not to_emails:
                logger.error("No recipient email addresses configured")
                return False

            if not from_email:
                logger.error("No from_email configured")
                return False

            # Build email
            subject = self._build_subject(payload)
            html_body = self._build_html_body(payload)
            text_body = self._build_text_body(payload)

            # Send via appropriate method
            if self.method == 'sendgrid':
                return await self._send_via_sendgrid(
                    from_email,
                    to_emails,
                    subject,
                    html_body,
                    text_body
                )
            else:  # smtp
                return await self._send_via_smtp(
                    from_email,
                    to_emails,
                    subject,
                    html_body,
                    text_body,
                    channel_config
                )

        except Exception as e:
            logger.error(f"Error sending email notification: {e}")
            return False

    def _build_subject(self, payload: Dict) -> str:
        """Build email subject line"""
        severity = payload.get('severity', 'medium').upper()
        title = payload.get('title', 'SEO Alert')

        return f"[{severity}] {title}"

    def _build_text_body(self, payload: Dict) -> str:
        """Build plain text email body"""
        title = payload.get('title', 'SEO Alert')
        message = payload.get('message', '')
        property_url = payload.get('property', '')
        severity = payload.get('severity', 'medium')

        body = f"""
{title}

{message}

---
Property: {property_url}
Severity: {severity.upper()}

This alert was generated by the SEO Intelligence Platform.
        """.strip()

        return body

    def _build_html_body(self, payload: Dict) -> str:
        """Build HTML email body with styling"""
        title = payload.get('title', 'SEO Alert')
        message = payload.get('message', '').replace('\n', '<br>')
        property_url = payload.get('property', '')
        severity = payload.get('severity', 'medium')
        metadata = payload.get('metadata', {})

        # Get severity color
        color = self.SEVERITY_COLORS.get(severity, '#808080')

        # Build metadata table
        metadata_rows = ''
        if metadata:
            for key, value in metadata.items():
                metadata_rows += f"""
                <tr>
                    <td style="padding: 8px; border-bottom: 1px solid #eee; font-weight: bold; width: 30%;">{key}</td>
                    <td style="padding: 8px; border-bottom: 1px solid #eee;">{value}</td>
                </tr>
                """

        html = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
    <div style="border-left: 4px solid {color}; padding-left: 20px; margin-bottom: 20px;">
        <h2 style="margin: 0; color: {color};">{title}</h2>
        <p style="margin: 5px 0 0 0; color: #666; font-size: 12px; text-transform: uppercase;">
            Severity: {severity}
        </p>
    </div>

    <div style="background-color: #f9f9f9; padding: 20px; border-radius: 5px; margin-bottom: 20px;">
        <p style="margin: 0;">{message}</p>
    </div>

    <div style="margin-bottom: 20px;">
        <h3 style="margin: 0 0 10px 0; font-size: 16px;">Property</h3>
        <p style="margin: 0;">
            <a href="{property_url}" style="color: #0066cc; text-decoration: none;">{property_url}</a>
        </p>
    </div>

    {f'''
    <div style="margin-bottom: 20px;">
        <h3 style="margin: 0 0 10px 0; font-size: 16px;">Details</h3>
        <table style="width: 100%; border-collapse: collapse; background-color: #fff;">
            {metadata_rows}
        </table>
    </div>
    ''' if metadata_rows else ''}

    <div style="border-top: 2px solid #eee; padding-top: 20px; margin-top: 30px; text-align: center; color: #999; font-size: 12px;">
        <p style="margin: 0;">
            This alert was generated by the <strong>SEO Intelligence Platform</strong>
        </p>
    </div>
</body>
</html>
        """.strip()

        return html

    async def _send_via_smtp(
        self,
        from_email: str,
        to_emails: List[str],
        subject: str,
        html_body: str,
        text_body: str,
        config: Dict
    ) -> bool:
        """
        Send email via SMTP

        Args:
            from_email: Sender email
            to_emails: Recipient emails
            subject: Email subject
            html_body: HTML body
            text_body: Plain text body
            config: SMTP configuration

        Returns:
            True if sent successfully
        """
        try:
            # Get SMTP configuration
            smtp_host = config.get('smtp_host', self.smtp_config.get('smtp_host', 'smtp.gmail.com'))
            smtp_port = config.get('smtp_port', self.smtp_config.get('smtp_port', 587))
            smtp_user = config.get('smtp_user', self.smtp_config.get('smtp_user', from_email))
            smtp_pass = config.get('smtp_pass', self.smtp_config.get('smtp_pass'))

            if not smtp_pass:
                logger.error("No SMTP password configured")
                return False

            # Create message
            msg = MIMEMultipart('alternative')
            msg['From'] = from_email
            msg['To'] = ', '.join(to_emails)
            msg['Subject'] = subject

            # Attach parts
            part1 = MIMEText(text_body, 'plain')
            part2 = MIMEText(html_body, 'html')

            msg.attach(part1)
            msg.attach(part2)

            # Send via SMTP (run in thread to avoid blocking)
            await asyncio.get_event_loop().run_in_executor(
                None,
                self._send_smtp_sync,
                smtp_host,
                smtp_port,
                smtp_user,
                smtp_pass,
                from_email,
                to_emails,
                msg
            )

            logger.info(f"Email sent to {len(to_emails)} recipient(s)")
            return True

        except Exception as e:
            logger.error(f"Error sending via SMTP: {e}")
            return False

    def _send_smtp_sync(
        self,
        host: str,
        port: int,
        user: str,
        password: str,
        from_email: str,
        to_emails: List[str],
        msg: MIMEMultipart
    ):
        """Synchronous SMTP send (for executor)"""
        with smtplib.SMTP(host, port) as server:
            server.starttls()
            server.login(user, password)
            server.sendmail(from_email, to_emails, msg.as_string())

    async def _send_via_sendgrid(
        self,
        from_email: str,
        to_emails: List[str],
        subject: str,
        html_body: str,
        text_body: str
    ) -> bool:
        """
        Send email via SendGrid API

        Args:
            from_email: Sender email
            to_emails: Recipient emails
            subject: Email subject
            html_body: HTML body
            text_body: Plain text body

        Returns:
            True if sent successfully
        """
        try:
            if not self.sendgrid_api_key:
                logger.error("No SendGrid API key configured")
                return False

            # Build SendGrid payload
            payload = {
                "personalizations": [
                    {
                        "to": [{"email": email} for email in to_emails],
                        "subject": subject
                    }
                ],
                "from": {"email": from_email},
                "content": [
                    {"type": "text/plain", "value": text_body},
                    {"type": "text/html", "value": html_body}
                ]
            }

            # Send to SendGrid
            headers = {
                'Authorization': f'Bearer {self.sendgrid_api_key}',
                'Content-Type': 'application/json'
            }

            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.post(
                    'https://api.sendgrid.com/v3/mail/send',
                    json=payload,
                    headers=headers
                )

            if response.status_code in [200, 201, 202]:
                logger.info(f"Email sent via SendGrid to {len(to_emails)} recipient(s)")
                return True
            else:
                logger.error(f"SendGrid API error: {response.status_code} - {response.text}")
                return False

        except Exception as e:
            logger.error(f"Error sending via SendGrid: {e}")
            return False

    async def send_test_email(
        self,
        to_email: str,
        config: Dict
    ) -> bool:
        """
        Send a test email

        Args:
            to_email: Recipient email
            config: Email configuration

        Returns:
            True if sent successfully
        """
        payload = {
            'title': 'Test Alert',
            'message': 'This is a test notification from the SEO Intelligence Platform.\n\nIf you received this email, email notifications are working correctly.',
            'severity': 'low',
            'property': 'https://example.com',
            'metadata': {
                'Test Type': 'Email Delivery Test',
                'Timestamp': asyncio.get_event_loop().time()
            }
        }

        config['to_emails'] = [to_email]

        return await self.send(payload, config)


# Synchronous wrapper
def send_email_notification_sync(payload: Dict, config: Dict) -> bool:
    """Synchronous wrapper for sending email notifications"""
    notifier = EmailNotifier()
    return asyncio.run(notifier.send(payload, config))


__all__ = ['EmailNotifier']
